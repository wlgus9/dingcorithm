# 시간복잡도
입력값과 문제를 해결하는 데 걸리는 시간과의 상관관계

# 공간복잡도
입력값과 문제를 해결하는 데 걸리는 공간과의 상관관계

# Array와 LinkedList
데이터의 접근하는 경우가 많을 땐 `Array`, 삽입/삭제가 많을 땐 `LinkedList`

## Array
크기가 정해진 데이터의 공간

각 원소에 즉시 접근 가능
> 즉시 접근 가능하다 == 상수 시간 내에 접근할 수 있음.

데이터를 새로 추가하려면 새로운 공간을 할당해야 하므로 비효율적

> 조회 : O(1), 삽입/삭제 : O(N)

## LinkedList
크기가 정해지지 않은 데이터의 공간

특정 원소(노드)에 접근하려면 연결 고리(포인터)를 따라 탐색해야 함

최악의 경우에는 모든 원소를 탐색해야 하므로 O(N)의 시간복잡도를 가짐

데이터를 새로 추가하려면 공간이 다 찼어도 맨 뒤의 노드만 동적으로 추가해주면 됨

> 조회 : O(N), 삽입/삭제 : O(1)

# 이진 탐색과 재귀 함수

## 이진 탐색
탐색 범위를 반으로 줄이면서 값을 찾아나가는 알고리즘

탐색하기 위해서는 정렬되어 있어야 함

> 시간복잡도 : O(log N)

## 재귀 함수
자기 자신을 호출하는 함수

함수를 빠져나가는 조건(탈출 조건)을 정확히 명시해 줘야 함. 안 그러면 무한루프.

# 정렬
데이터를 순서대로 나열하는 방법을 의미

## 버블 정렬
서로 인접한 두 원소의 크기를 비교해 정렬

> 시간복잡도 : O(n²)

## 선택 정렬
대상 데이터에서 최소(최대)값을 선택하고 현재 데이터와 위치를 교환하는 방식으로 정렬

> 시간복잡도 : O(n²)

## 삽입 정렬
데이터를 하나씩 확인하면서 각 데이터를 적절한 위치에 삽입하는 방식으로 정렬

> 시간복잡도 : O(n²)

## 병합 정렬
하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 후 하나로 합치면서 전체가 정렬된 리스트가 되게 하는 방식

분할 정복 알고리즘 중 하나

### 분할 정복 (Divide & Conquer)
문제를 작은 2개의 문제로 분리하고 각각 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략

# 스택
데이터를 한쪽 끝에서만 삽입하거나 삭제할 수 있는 자료구조

LIFO(Last In First Out)

스택의 기본 연산
* `push`: 데이터 삽입
* `pop` : 데이터 삭제 및 반환
* `peek`/`top` : 스택의 최상위 요소 확인
* `isEmpty` : 스택에 데이터 존재 여부 확인

# 큐
한쪽 끝에서는 데이터를 삽입하고 반대쪽 끝에서는 데이터를 삭제할 수 있는 자료구조

FIFO(First In First Out)

큐의 기본 연산
* `enqueue` : 데이터 삽입
* `dequeue` : 데이터 삭제 및 반환
* `front` : 큐의 최상위 요소 확인